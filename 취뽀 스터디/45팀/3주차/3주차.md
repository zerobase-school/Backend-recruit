# 45팀 취뽀스터디 3주차(2024.08.07 10:00~11:00)

---

## 재귀 함수 - 안연정

🟩 재귀
하나의 함수에서 자기 자신을 다시 호출하여 작업을 수행하는 알고리즘

🟩 수학적 귀납법
절차지향적 사고

    🟩 3 출력

    🟩 func1(2) 호출 → 2 출력

    🟩 func1(1) 호출 → 1 출력

    🟩 func1(0)호출 → return;

1.  func1(1)이 1을 출력한다.

2.  func1(k) 가 k k-1 k-2 … 1을 출력한다.

3.  func1(k+1) 가 k+1 k k-1 k-2 … 1을 출력한다

🟩 재귀 함수의 조건

    특정 입력에 대해서는 자기 자신을 호출하지않고 종료되어야 함(Base Condition) → 모든 입력은 Base Condition 으로 수렴해야 함

🟩 재귀 함수의 특징

🟩 함수의 인자로 어떤 것을 받고, 어디까지 계산한 후
    자기 자신에게(인자로) 넘겨줄지 명확하게 정해야 함

🟩모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있다.

🟩 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만, 함수 호출은 비용이 큰 연산이기때문에, 메모리와 시간에서 손해를 봄

🟩 재귀함수가 자기 자신을 여러 번 호출하면 예상과 다르게 비효율적일 수 있음


# 연습문제 - Z(BOJ 1074)
문제
한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.


만약, N > 1이 라서 왼쪽 위에 있는 칸이 하나가 아니라면, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.

다음 예는 22 × 22 크기의 배열을 방문한 순서이다.


N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.


 🟩 1. 함수의 정의 
        int func(int n, int r, int c)
        2^n * 2^n 배열에서 (r,c)를 방문하는 순서를 반환하는 함수

🟩 2. base condition
    n = 0 일 때 return 0;

🟩 3. 재귀식 
    (1) 배열을 4등분으로 나눠, 입력받은 r과 c가 몇번째 면에 속하는 지 확인 
    (2) 호출할때마다 현재 r,c 의 위치(상대적)에 따라 앞에 몇번 방문 했는 지 더하는 변수 count 선언
    (3) 메소드를 정의 하고 매개변수로 한변의 사이즈 와 상대적인 타겟 위치 r,c 를 넘겨 받는다 



🟩 풀이 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	static int count = 0;

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(br.readLine());

		int N = Integer.parseInt(st.nextToken());

		int r = Integer.parseInt(st.nextToken());

		int c = Integer.parseInt(st.nextToken()); 

		int size = (int) Math.pow(2, N); 

	
		find(size, r, c);
		System.out.println(count);
	}

	private static void find(int size, int r, int c) {
		if(size == 1)
			return;
		
		if(r < size/2 && c < size/2) {
			find(size/2, r, c);
		}
		else if(r < size/2 && c >= size/2) {
			count += size * size / 4;
			find(size/2, r, c - size/2);
		}
		else if(r >= size/2 && c < size/2) {
			count += (size * size / 4) * 2;
			find(size/2, r - size/2, c);
		}
		else {
			count += (size * size / 4) * 3;
			find(size/2, r - size/2, c - size/2);
		}
	}
}

---

## 운영체제 - 장현수

🟩 프로세스 ? 쓰레드 ?

    --> 프로세스란?
    운영체제로부터 자원을 할당받아 실행하는 작업의 단위
    (실행 중인 프로그램의 인스턴스)


    --> 쓰레드란?
    프로세스로부터 자원을 할당받아 실행하는
    작업의 단위
    (프로세스 내에서 실행되는 가장 작은 작업 단위)


    추가!! 프로세스 구조?
    프로세스는 일반적으로
    CODE 영역, DATA 영역, HEAP 영역, STACK 영역으로 나눕니다

    CODE 영역  프로그램 코드가 저장된 영역
    DATA 영역  전역 변수와 정적 변수가 저장되는 영역
    HEAP 영역  프로세스 실행 중 동적으로 할당된 메모리를 위한 공간
    STACK 영역  함수 실행을 위한 지역 변수등이 저장되는 영역

🟩 컨텍스트 스위칭 ?

    --> 컨텍스트 스위칭 이란?

     멀티태스킹 환경에서 프로세스 스위칭이 필요할 때 실행할 프로세스를 CPU에 교체해주는 기술
     즉, 여러 프로세스나 스레드가 CPU를 공유하며 동시에 실행되는 것처럼 보이도록 하기 위해 필수적인 기능

🟩 멀티 프로세스 ? 멀티 쓰레드 ?

    멀티 프로세스 : 여러 개의 프로세스를 동시에 실행하는 방식

    멀티 쓰레드 : 하나의 프로세스 내에서 여러 개의 스레드를 동시에 실행하는 방식


    멀티 쓰레드의 문제점 : 프로세스의 주소공간을 공유하고 있기때문에 IPC 와 같은 프로세스 통신 기술은 필요가 없습니다

    그러나 공유한 데이터를 빈번하게 읽고 쓰는 과정에서 동기화 문제가 발생 비정상 동작 일어날 수 있음

🟩 쓰레드 동기화 ?

    멀티 쓰레드 환경에서 동일한 자원을 읽고 쓸 시에 발생하는 문제가 있음

    이러한 문제를 막기 위해 여러 쓰레드가 동시에 동일한 자원의 읽고 쓰지 못하도록 하는 기술

🟩 뮤텍스와 세마포어 ?

    뮤텍스 : 쓰레드간 공유한 자원을 접근 시,
    일정 순간에 하나의 쓰레드만 특정 자원에 접근할 수 있도록 하는 동기화 기술

    세마포어 : 쓰레드간 공유한 자원을 접근 시, 일정 순간에 정한 쓰레드수만큼 특정 자원에 접근할 수 있도록 하는 동기화 기술


---

## 트랜잭션 - 윤영식

🟩 트랜잭션(Transaction)은 데이터베이스 시스템에서 사용되는 개념으로, 

    데이터베이스의 상태를 변화시키기 위해 수행되는 일련의 작업들을 의미합니다. 

    트랜잭션은 하나의 논리적인 작업 단위로 간주되며, 여러 작업이 묶여서 하나의 트랜잭션을 구성하게 됩니다.

🟩 트랜잭션의 4가지 특성 (ACID 특성)

    🟩 Atomicity (원자성): 트랜잭션 내의 모든 작업이 완전히 수행되거나, 전혀 수행되지 않아야 한다는 것을 의미합니다. 즉, 트랜잭션이 도중에 실패하면 모든 작업이 롤백(되돌리기)되어 원래 상태로 돌아가야 합니다.

    🟩 Consistency (일관성): 트랜잭션이 성공적으로 완료되면 데이터베이스는 항상 일관된 상태를 유지해야 합니다. 트랜잭션 전후의 데이터 상태가 정합성을 유지해야 한다는 의미입니다.

    🟩 Isolation (격리성): 동시에 여러 트랜잭션이 실행되더라도, 각 트랜잭션은 독립적으로 실행되어야 합니다. 한 트랜잭션의 중간 작업이 다른 트랜잭션에 영향을 미치지 않아야 합니다.

    🟩 Durability (지속성): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 하며, 시스템이 고장 나더라도 데이터는 보존되어야 합니다.